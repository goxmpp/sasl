package scram

import (
	"bytes"
	"crypto/hmac"
	"hash"
	"strconv"

	"github.com/azhavnerchik/sasl"
)

const (
	CLIENT_KEY   = "Client Key"
	SERVER_KEY   = "Server Key"
	SALT_BYTES   = 32
	NONCE_BYTES  = 20
	CNONCE_BYTES = 21
)

var DefaultGenerator sasl.Generator

type HashConstructor func() hash.Hash

type scram struct {
	cons HashConstructor    // Hash function constructor used in Scram
	gen  sasl.SaltGenerator // Salt, Nonce and Iterations generator

	salted_password []byte // Salted password
	salt            []byte // Salt generated by server
	iterate         int    // Number of iterations during password salting
	client_nonce    []byte // Client's nonce
	server_nonce    []byte // Server's nonce concatenated to client's nonce
	proof_sig       []byte // Proof calculated from salted password
	username        []byte // User name provided in Client First message
	auth_id         []byte // Authorization identity usually empty
	binding         byte   // binding indicator used for GS2
}

// Created new object that can be used for authentication session.
// Requires:
// - Hash function constructor
// - boolean to specify if channel binding is supported. Binding is not really implemented yet
// - optional generator object. nil can be provided - then default generator will be used
func newScram(cons HashConstructor, use_binding bool, gen sasl.SaltGenerator) *scram {
	if gen == nil {
		gen = DefaultGenerator
	}

	var binding byte = 'n'
	if use_binding {
		binding = 'p'
	}

	return &scram{cons: cons, gen: gen, binding: binding}
}

// Returns true if channel binding is supported
func (s *scram) BindingSupported() bool {
	return s.binding == 'y'
}

// Sets salt, salted_password and iterations count for further processing.
// This method allows to have salted password and related info stored and
// provided at authentications stage. So you won't need to store it in plain text
func (s *scram) SetSaltedPassword(spassword []byte, salt []byte, iterations int) {
	s.iterate = iterations
	s.salted_password = spassword
	s.salt = salt
}

// Gererates (if necessary) and returns salt as slice of bites.
// If Salt was parsed from Server First message - just returns salt parsed from that message
func (s *scram) Salt() []byte {
	if len(s.salt) == 0 {
		s.salt = s.gen.GetSalt(SALT_BYTES)
	}

	// Return a copy of generated salt, so user can modify it as she wants
	return sasl.MakeCopy(s.salt)
}

// Salts password and retrun salted password as slice of bytes.
// Salt and Iterations values will be generated as needed
// if they were not parsed from Server First message
func (s *scram) SaltPassword(password []byte) []byte {
	mac := hmac.New(s.cons, password)

	salt := s.Salt()
	salt = append(salt, 0x00, 0x00, 0x00, 0x01)

	prev := salt
	var result []byte
	for i := 0; i < s.iterations(); i++ {
		mac.Write(prev)
		prev = mac.Sum(nil)

		if len(result) == 0 {
			result = prev
		} else {
			result = byteXOR(result, prev)
		}

		mac.Reset()
	}

	s.salted_password = result

	return sasl.MakeCopy(s.salted_password)
}

func (s *scram) checkBinding(client_final []byte) error {
	bind, err := extractParameter(client_final, 'c')
	if err != nil {
		return err
	}

	if !bytes.Equal(sasl.Base64ToBytes(s.bindString()), bind) {
		return WrongClientMessage("Invalid binding specified")
	}

	return nil
}

// Check's that received proof matches expected one
func (s *scram) checkProof(proof []byte) bool {
	if len(s.salted_password) == 0 {
		panic("Salt password first") // TODO refactor this
	}

	storek := s.getHash(s.getClientKey())

	client_sig := s.getClientSignature(s.authMessage(), storek)

	rck := byteXOR(client_sig, proof)

	return bytes.Equal(s.getHash(rck), storek)
}

// Returns slice of bytes used in Server Final message
func (s *scram) verification() []byte {
	return s.getServerSignature(s.authMessage(), s.getServerKey())
}

// Genarates (if necessary) and returns CNonce as string
// If CNonce was parsed from Client First message - parsed value will be returned
func (s *scram) cnonce() []byte {
	if len(s.client_nonce) == 0 {
		s.client_nonce = s.gen.GetNonce(CNONCE_BYTES)
	}
	return s.client_nonce
}

// Genarates (if necessary) and returns Nonce as string
// If Nonce was parsed from Server First message - parsed value will be returned
func (s *scram) nonce() []byte {
	if len(s.server_nonce) == 0 {
		s.server_nonce = append(sasl.MakeCopy(s.cnonce()), s.gen.GetNonce(NONCE_BYTES)...)
	}
	return s.server_nonce
}

// Genarates (if necessary) and returns Iterations count as int
// If Iterations was parsed from Server First message - parsed value will be returned
func (s *scram) iterations() int {
	if s.iterate == 0 {
		s.iterate = s.gen.GetIterations()
	}
	return s.iterate
}

func (s *scram) serverFirst() []byte {
	return sasl.MakeMessage(
		makeKeyValue('r', s.nonce()),
		makeKeyValue('s', sasl.Base64ToBytes(s.Salt())),
		makeKeyValue('i', []byte(strconv.Itoa(s.iterations()))),
	)
}

func (s *scram) proof() []byte {
	if len(s.proof_sig) == 0 {
		if len(s.salted_password) == 0 {
			panic("Salt password first")
		}

		clientk := s.getClientKey()

		storek := s.getHash(clientk)

		client_sig := s.getClientSignature(s.authMessage(), storek)

		s.proof_sig = byteXOR(client_sig, clientk)
	}

	return s.proof_sig
}

func (s *scram) getHash(client_key []byte) []byte {
	h := s.cons()
	h.Write(client_key)
	return h.Sum(nil)
}

func (s *scram) bareClientFirst() []byte {
	return sasl.MakeMessage(makeKeyValue('n', s.username), makeKeyValue('r', s.cnonce()))
}

func (s *scram) bindString() []byte {
	// Client first message should start with 'n', 'y' or 'p'
	// otherwise it should be treated as invalid
	bind := []byte{s.binding, ','}
	if len(s.auth_id) > 0 {
		bind = append(bind, makeKeyValue('a', s.auth_id)...)
	}
	return append(bind, ',')
}

func (s *scram) clientReplyNotProof() []byte {
	return sasl.MakeMessage(makeKeyValue('c', sasl.Base64ToBytes(s.bindString())), makeKeyValue('r', s.nonce()))
}

func (s *scram) authMessage() []byte {
	return sasl.MakeMessage(s.bareClientFirst(), s.serverFirst(), s.clientReplyNotProof())
}

func (s *scram) getClientKey() []byte {
	mac := hmac.New(s.cons, s.salted_password)
	mac.Write([]byte(CLIENT_KEY))
	return mac.Sum(nil)
}

func (s *scram) getServerKey() []byte {
	mac := hmac.New(s.cons, s.salted_password)
	mac.Write([]byte(SERVER_KEY))
	return mac.Sum(nil)
}
func (s *scram) getServerSignature(auth []byte, serverk []byte) []byte {
	ssmac := hmac.New(s.cons, serverk)
	ssmac.Write(auth)
	return ssmac.Sum(nil)
}

func (s *scram) getClientSignature(auth []byte, storek []byte) []byte {
	skmac := hmac.New(s.cons, storek)
	skmac.Write(auth)
	return skmac.Sum(nil)
}
