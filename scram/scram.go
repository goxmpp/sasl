package scram

import (
	"crypto/hmac"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"hash"
	mrand "math/rand"
	"strings"
	"time"
)

const (
	CLIENT_KEY     = "Client Key"
	SERVER_KEY     = "Server Key"
	MIN_ITERATIONS = 4096
	MAX_ITERATIONS = 10000
)

type scram struct {
	cons func() hash.Hash // Hash function constructor used in scram

	password        string // Plain text password
	salted_password []byte // Salted password
	salt            []byte // Salt generated by server
	iterations      int    // Number of iterations during password salting
	cnonce          string // Client's nonce
	nonce           string // Server's nonce concatenated to client's nonce
	proof           []byte // Proof calculated from salted password
	username        string // User name provided in Client First message
	auth_id         string // Authorization identity usually empty
	binding         byte   // binding indicator used for GS2
}

func New(cons func() hash.Hash) *scram {
	return &scram{}
}

func (s *scram) UserName() string {
	return s.username
}

func (s *scram) ClientFirst(username string) string {
	s.username = saslPrepare(username)
	return fmt.Sprintf("%s,%s", s.bindString(), s.bareClientFirst())
}

func (s *scram) ServerFirst(salt []byte, iterations int) string {
	s.setSalt(salt)
	s.setIterations(iterations)
	return s.serverFirst()
}

func (s *scram) serverFirst() string {
	return fmt.Sprintf("r=%s,s=%s,i=%d", s.nonce, base64.StdEncoding.EncodeToString(s.Salt()), s.Iterations())
}

func (s *scram) ClientReply() string {
	if len(s.proof) == 0 {
		s.genProof()
	}

	return fmt.Sprintf("%s,p=%s", s.clientReplyNotProof(), base64.StdEncoding.EncodeToString(s.proof))
}

func (s *scram) ServerReply() string {
	ss := base64.StdEncoding.EncodeToString(s.getServerSignature(s.authMessage(), s.getServerKey()))
	return fmt.Sprintf("v=%s", ss)
}

func (s *scram) ParseClientFirst(client_first string) {

}

func (s *scram) ParseServerFirst(server_first string) {

}

func (s *scram) CheckProof() bool {
	if len(s.salted_password) == 0 {
		s.SaltPassword([]byte(s.password))
	}

	storek := s.getHash(s.getClientKey())

	client_sig := s.getClientSignature(s.authMessage(), storek)

	rck := byteXOR(client_sig, s.proof)

	return fmt.Sprintf("%x", s.getHash(rck)) == fmt.Sprintf("%x", storek)
}

func (s *scram) setSalt(salt []byte) {
	if len(salt) > 0 {
		s.salt = make([]byte, len(salt))
		copy(s.salt, salt)
	}
}

func (s *scram) Salt() []byte {
	if len(s.salt) == 0 {
		s.salt = make([]byte, 30)
		if _, err := rand.Read(s.salt); err != nil {
			panic(err) // Just die
		}
	}

	// Return a copy of generated salt, so user can modify it as she wants
	result := make([]byte, len(s.salt))
	copy(result, s.salt)
	return result
}

func (s *scram) getHash(client_key []byte) []byte {
	h := s.cons()
	h.Write(client_key)
	return h.Sum(nil)
}

func saslPrepare(username string) string {
	panic("Not implemented")
}

func (s *scram) genProof() {
	if len(s.salted_password) == 0 {
		s.SaltPassword([]byte(s.password))
	}

	clientk := s.getClientKey()

	storek := s.getHash(clientk)

	client_sig := s.getClientSignature(s.authMessage(), storek)

	s.proof = byteXOR(client_sig, clientk)
}

func (s *scram) setIterations(iterations int) int {
	if iterations != 0 && iterations > MIN_ITERATIONS {
		s.iterations = iterations
	}
	return s.iterations
}

func (s *scram) Iterations() int {
	if s.iterations == 0 { // Generate if not set
		mrand.Seed(time.Now().UnixNano())
		s.iterations = MIN_ITERATIONS + mrand.Intn(MAX_ITERATIONS-MIN_ITERATIONS)
	}
	return s.iterations
}

func (s *scram) SaltPassword(password []byte) []byte {
	mac := hmac.New(s.cons, password)

	salt := s.Salt()
	salt = append(salt, 0x00, 0x00, 0x00, 0x01)

	prev := salt
	var result []byte
	for i := 0; i < s.Iterations(); i++ {
		mac.Write(prev)
		prev = mac.Sum(nil)

		if len(result) == 0 {
			result = prev
		} else {
			result = byteXOR(result, prev)
		}

		mac.Reset()
	}

	s.salted_password = result

	return s.salted_password
}

func (s *scram) bareClientFirst() string {
	return fmt.Sprintf("n=%s,r=%s", s.username, s.cnonce)
}

func (s *scram) bindString() string {
	// Client first message should start with 'n', 'y' or 'p'
	// otherwise it should be treated as invalid
	authid := ""
	if len(s.auth_id) > 0 {
		authid = fmt.Sprintf("a=%s", s.auth_id)
	}
	return fmt.Sprintf("%c,%s", s.binding, authid)
}

func (s *scram) clientReplyNotProof() string {
	return fmt.Sprintf("c=%s,r=%s", base64.StdEncoding.EncodeToString([]byte(s.bindString())), s.nonce)
}

func (s *scram) authMessage() string {
	return strings.Join([]string{s.bareClientFirst(), s.serverFirst(), s.clientReplyNotProof()}, ",")
}

func byteXOR(left, right []byte) []byte {
	res := make([]byte, len(left))
	for i := range left {
		res[i] = left[i] ^ right[i]
	}
	return res
}

func (s *scram) getClientKey() []byte {
	mac := hmac.New(s.cons, s.salted_password)
	mac.Write([]byte(CLIENT_KEY))
	return mac.Sum(nil)
}

func (s *scram) getServerKey() []byte {
	mac := hmac.New(s.cons, s.salted_password)
	mac.Write([]byte(SERVER_KEY))
	return mac.Sum(nil)
}
func (s *scram) getServerSignature(auth string, serverk []byte) []byte {
	ssmac := hmac.New(s.cons, serverk)
	ssmac.Write([]byte(auth))
	return ssmac.Sum(nil)
}

func (s *scram) getClientSignature(auth string, storek []byte) []byte {
	skmac := hmac.New(s.cons, storek)
	skmac.Write([]byte(auth))
	return skmac.Sum(nil)
}
