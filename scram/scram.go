package scram

import (
	"bytes"
	"crypto/hmac"
	"encoding/base64"
	"fmt"
	"hash"
	"strconv"
	"strings"
)

const (
	CLIENT_KEY = "Client Key"
	SERVER_KEY = "Server Key"
)

var DefaultGenerator Generators

type Generator interface {
	// Method used in CNonce and Nonce generation
	GetNonce() string
	// Salt derivation function
	GetSalt() []byte
	// Iterations count derivation function
	GetIterations() int
}

type HashConstructor func() hash.Hash

type Scram struct {
	cons HashConstructor // Hash function constructor used in Scram
	gen  Generator       // Salt, Nonce and Iterations generator

	salted_password []byte // Salted password
	salt            []byte // Salt generated by server
	iterations      int    // Number of iterations during password salting
	cnonce          string // Client's nonce
	nonce           string // Server's nonce concatenated to client's nonce
	proof           []byte // Proof calculated from salted password
	username        string // User name provided in Client First message
	auth_id         string // Authorization identity usually empty
	binding         byte   // binding indicator used for GS2
}

// Created new object that can be used for authentication session.
// Requires:
// - Hash function constructor
// - boolean to specify if channel binding is supported
// - optional generator object. nil can be provided - then default generator will be used
func New(cons HashConstructor, use_binding bool, gen Generator) *Scram {
	if gen == nil {
		gen = DefaultGenerator
	}

	var binding byte = 'n'
	if use_binding {
		binding = 'y'
	}

	return &Scram{cons: cons, gen: gen, binding: binding}
}

// Returns true if channel binding is supported
func (s *Scram) BindingSupported() bool {
	return s.binding == 'y'
}

// Returns AuthID for current authentication session.
// If Client First message didn't provide AuthID - UserName will be used
func (s *Scram) AuthID() string {
	if s.auth_id != "" {
		return s.auth_id
	}
	return s.username
}

// Returns UserName provided for Client First message
func (s *Scram) UserName() string {
	return s.username
}

// Generates Client First message
func (s *Scram) ClientFirst(username string) string {
	s.username = saslPrepare(username)
	return fmt.Sprintf("%s%s", s.bindString(), s.bareClientFirst())
}

// Generates Server First message. SaltPassword should be called before this method usage
func (s *Scram) ServerFirst() string {
	return s.serverFirst()
}

// Generated Client Final message. SaltPassword should be called before this method usage
func (s *Scram) ClientReply() string {
	return fmt.Sprintf("%s,p=%s", s.clientReplyNotProof(), base64.StdEncoding.EncodeToString(s.Proof()))
}

// Generates Server Final Message
func (s *Scram) ServerReply() string {
	return fmt.Sprintf("v=%s", base64.StdEncoding.EncodeToString(s.Verification()))
}

// Returns slice of bytes used in Server Final message
func (s *Scram) Verification() []byte {
	return s.getServerSignature(s.authMessage(), s.getServerKey())
}

// Parses Client First message and populates Scram's internal fields
// related to binding, auth_id, username, cnonce
func (s *Scram) ParseClientFirst(client_first []byte) error {
	auth_pref := []byte{'a', '='}

	if err := validateMessage(client_first); err != nil {
		return err
	}

	return eachToken(client_first, ',', func(token []byte) error {
		switch {
		case len(token) == 1 && (token[0] == 'n' || token[0] == 'y'):
			s.binding = token[0]
		case len(token) == 0 || bytes.HasPrefix(token, auth_pref):
			s.auth_id = ""
			if bytes.HasPrefix(token, auth_pref) {
				_, v := extractKeyValue(token, '=')
				s.auth_id = saslDePrep(v)
			}
		case bytes.HasPrefix(token, []byte{'n', '='}):
			_, v := extractKeyValue(token, '=')
			s.username = saslDePrep(v)
		case bytes.HasPrefix(token, []byte{'r', '='}):
			_, v := extractKeyValue(token, '=')
			s.cnonce = string(v)
		default:
			return WrongClientMessage("Unknown field")
		}
		return nil
	})
}

// Parses Server First message and populates Scram's internal fields
// like server nonce, salt, iterations count
func (s *Scram) ParseServerFirst(server_first []byte) error {
	return eachToken(server_first, ',', func(token []byte) error {
		k, v := extractKeyValue(token, '=')
		if len(k) != 1 {
			return WrongServerMessage("Wrong key/value pair")
		}

		switch k[0] {
		case 'i':
			it, err := strconv.Atoi(string(v))
			if err != nil {
				return err
			}
			s.iterations = it
		case 'r':
			s.nonce = string(v)
		case 's':
			salt := make([]byte, base64.StdEncoding.DecodedLen(len(v)))
			if _, err := base64.StdEncoding.Decode(salt, v); err != nil {
				return err
			}
			s.salt = salt
		default:
			return WrongServerMessage("Unknown value provided")
		}
		return nil
	})
}

// Check's that received proof matches expected one
func (s *Scram) CheckProof(proof []byte) bool {
	if len(s.salted_password) == 0 {
		panic("Salt password first") // TODO refactor this
	}

	storek := s.getHash(s.getClientKey())

	client_sig := s.getClientSignature(s.authMessage(), storek)

	rck := byteXOR(client_sig, proof)

	return bytes.Equal(s.getHash(rck), storek)
}

// Gererates (if necessary) and returns salt as slice of bites.
// If Salt was parsed from Server First message - just returns salt parsed from that message
func (s *Scram) Salt() []byte {
	if len(s.salt) == 0 {
		s.salt = s.gen.GetSalt()
	}

	// Return a copy of generated salt, so user can modify it as she wants
	result := make([]byte, len(s.salt))
	copy(result, s.salt)
	return result
}

// Genarates (if necessary) and returns CNonce as string
// If CNonce was parsed from Client First message - parsed value will be returned
func (s *Scram) CNonce() string {
	if len(s.cnonce) == 0 {
		s.cnonce = s.gen.GetNonce()
	}
	return s.cnonce
}

// Genarates (if necessary) and returns Nonce as string
// If Nonce was parsed from Server First message - parsed value will be returned
func (s *Scram) Nonce() string {
	if len(s.nonce) == 0 {
		s.nonce = s.CNonce() + s.gen.GetNonce()
	}
	return s.nonce
}

// Generates (if wasn't generated before) and returns proof as slice of bytes
func (s *Scram) Proof() []byte {
	if len(s.proof) == 0 {
		s.genProof()
	}

	return s.proof
}

// Genarates (if necessary) and returns Iterations count as int
// If Iterations was parsed from Server First message - parsed value will be returned
func (s *Scram) Iterations() int {
	if s.iterations == 0 {
		s.iterations = s.gen.GetIterations()
	}
	return s.iterations
}

// Salts password and retrun salted password as slice of bytes.
// Salt and Iterations values will be generated as needed
// if they were not parsed from Server First message
func (s *Scram) SaltPassword(password []byte) []byte {
	mac := hmac.New(s.cons, password)

	salt := s.Salt()
	salt = append(salt, 0x00, 0x00, 0x00, 0x01)

	prev := salt
	var result []byte
	for i := 0; i < s.Iterations(); i++ {
		mac.Write(prev)
		prev = mac.Sum(nil)

		if len(result) == 0 {
			result = prev
		} else {
			result = byteXOR(result, prev)
		}

		mac.Reset()
	}

	s.salted_password = result

	return s.salted_password
}

func (s *Scram) serverFirst() string {
	return fmt.Sprintf("r=%s,s=%s,i=%d", s.Nonce(), base64.StdEncoding.EncodeToString(s.Salt()), s.Iterations())
}

func (s *Scram) genProof() {
	if len(s.salted_password) == 0 {
		panic("Salt password first")
	}

	clientk := s.getClientKey()

	storek := s.getHash(clientk)

	client_sig := s.getClientSignature(s.authMessage(), storek)

	s.proof = byteXOR(client_sig, clientk)
}

func (s *Scram) getHash(client_key []byte) []byte {
	h := s.cons()
	h.Write(client_key)
	return h.Sum(nil)
}

func (s *Scram) bareClientFirst() string {
	return fmt.Sprintf("n=%s,r=%s", s.username, s.CNonce())
}

func (s *Scram) bindString() string {
	// Client first message should start with 'n', 'y' or 'p'
	// otherwise it should be treated as invalid
	authid := ""
	if len(s.auth_id) > 0 {
		authid = fmt.Sprintf("a=%s", s.auth_id)
	}
	return fmt.Sprintf("%c,%s,", s.binding, authid)
}

func (s *Scram) clientReplyNotProof() string {
	return fmt.Sprintf("c=%s,r=%s", base64.StdEncoding.EncodeToString([]byte(s.bindString())), s.nonce)
}

func (s *Scram) authMessage() string {
	return strings.Join([]string{s.bareClientFirst(), s.serverFirst(), s.clientReplyNotProof()}, ",")
}

func (s *Scram) getClientKey() []byte {
	mac := hmac.New(s.cons, s.salted_password)
	mac.Write([]byte(CLIENT_KEY))
	return mac.Sum(nil)
}

func (s *Scram) getServerKey() []byte {
	mac := hmac.New(s.cons, s.salted_password)
	mac.Write([]byte(SERVER_KEY))
	return mac.Sum(nil)
}
func (s *Scram) getServerSignature(auth string, serverk []byte) []byte {
	ssmac := hmac.New(s.cons, serverk)
	ssmac.Write([]byte(auth))
	return ssmac.Sum(nil)
}

func (s *Scram) getClientSignature(auth string, storek []byte) []byte {
	skmac := hmac.New(s.cons, storek)
	skmac.Write([]byte(auth))
	return skmac.Sum(nil)
}
